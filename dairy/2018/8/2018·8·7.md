# js note and something

## 面向对象编程

### class继承

- 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。

```js
//class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。
class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
```

- 用`class`定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过`extends`来实现：

```js
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
```

注意PrimaryStudent的定义也是`class`关键字实现的，而`extends`则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过`super(name)`来调用父类的构造函数，否则父类的`name`属性无法正常初始化。

PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。

ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，`class`的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用`class`的好处就是极大地简化了原型链代码。

你一定会问，class这么好用，能不能现在就用上？

现在用还早了点，因为不是所有的主流浏览器都支持`ES6`的`class`。如果一定要现在就用上，就需要一个工具把`class`代码转换为传统的`prototype`代码，可以试试[`Babel`]这个工具。

```js
//练习
'use strict';
class Animal {
    constructor(name) {
        this.name = name;
    }
}
class Cat extends Animal {
    constructor(name) {
        super(name);
    }
    say() {
        return 'Hello, ' + this.name + '!';
    }
}
// 测试:
var kitty = new Cat('Kitty');
var doraemon = new Cat('哆啦A梦');
if ((new Cat('x') instanceof Animal) && kitty && kitty.name === 'Kitty' && kitty.say && typeof kitty.say === 'function' && kitty.say() === 'Hello, Kitty!' && kitty.say === doraemon.say) {
    console.log('测试通过!');
} else {
    console.log('测试失败!');
}
```

## [浏览器]

- IE 6~11：国内用得最多的`IE`浏览器，历来对W3C标准支持差。从`IE10`开始支持ES6标准；
- Chrome：`Google`出品的基于`Webkit`内核浏览器，内置了非常强悍的JavaScript引擎——`V8`。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持`ES6`了；
- Safari：`Apple`的Mac系统自带的基于`Webkit`内核的浏览器，从`OS X 10.7 Lion`自带的6.1版本开始支持`ES6`，目前最新的`OS X 10.11 El Capitan`自带的`Safari`版本是`9.x`，早已支持`ES6`；
- Firefox：`Mozilla`自己研制的`Gecko`内核和`JavaScript`引擎`OdinMonkey`。早期的`Firefox`按版本发布，后来终于聪明地学习`Chrome`的做法进行自升级，时刻保持最新；
- 移动设备上目前`iOS`和`Android`两大阵营分别主要使用`Apple`的`Safari`和Google的`Chrome`，由于两者都是`Webkit`核心，结果`HTML5`首先在手机上全面普及（桌面绝对是`Microsoft`拖了后腿），对`JavaScript`的标准支持也很好，最新版本均支持ES6。

其他浏览器如`Opera`等由于市场份额太小就被自动忽略了。

另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是`IE`，也有号称同时支持`IE`和`Webkit`的“双核”浏览器。

不同的浏览器对`JavaScript`支持的差异主要是，有些`API`的接口不一样，比如`AJAX，File接口`。对于ES6标准，不同的浏览器对各个特性支持也不一样。

在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。

### 浏览器对象

- JavaScript可以获取浏览器提供的很多对象，并进行操作。

#### windows

`window`对象不但充当全局作用域，而且表示浏览器窗口。

`window`对象有`innerWidth`和`innerHeight`属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。`兼容性：IE<=8不支持。`
对应的，还有一个`outerWidth`和`outerHeight`属性，可以获取浏览器窗口的整个宽高。

#### navigator

navigator对象表示浏览器的信息，最常用的属性包括：

- navigator.appName：浏览器名称；
- navigator.appVersion：浏览器版本；
- navigator.language：浏览器设置的语言；
- navigator.platform：操作系统类型；
- navigator.userAgent：浏览器设定的User-Agent字符串。

```js
console.log('appName = ' + navigator.appName);
console.log('appVersion = ' + navigator.appVersion);
console.log('language = ' + navigator.language);
console.log('platform = ' + navigator.platform);
console.log('userAgent = ' + navigator.userAgent);
```

- 但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回`undefined`的特性，直接用短路运算符`||`计算：`var width = window.innerWidth || document.body.clientWidth;`

#### screen

screen对象表示屏幕的信息，常用的属性有：

- screen.width：屏幕宽度，以像素为单位；
- screen.height：屏幕高度，以像素为单位；
- screen.colorDepth：返回颜色位数，如8、16、24。

`location`对象表示当前页面的URL信息。例如，一个完整的URL：`http://www.example.com:8080/path/index.html?a=1&b=2#TOP`,可以用location.href获取。要获得URL各个部分的值，可以这么写：

```js
location.protocol; // 'http'
location.host; // 'www.example.com'
location.port; // '8080'
location.pathname; // '/path/index.html'
location.search; // '?a=1&b=2'
location.hash; // 'TOP'
```

要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。

```js
'use strict';
if (confirm('重新加载当前页' + location.href + '?')) {
    location.reload();
} else {
    location.assign('/'); // 设置一个新的URL地址
}
```

#### document

`document`对象表示当前页面。由于`HTML`在浏览器中以`DOM`形式表示为树形结构，`document`对象就是整个`DOM`树的根节点。

`document`的`title`属性是从`HTML`文档中的`<title>xxx</title>`读取的，但是可以动态改变：`'use strict';document.title = 'JavaScript';`
要查找DOM树的某个节点，需要从`document`对象开始查找。最常用的查找是根据`ID`和`Tag Name`。
用`document`对象提供的`getElementById()`和`getElementsByTagName()`可以按`ID`获得一个`DOM`节点和按`Tag`名称获得一组`DOM`节点：

```html
<dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;">
    <dt>摩卡</dt>
    <dd>热摩卡咖啡</dd>
    <dt>酸奶</dt>
    <dd>北京老酸奶</dd>
    <dt>果汁</dt>
    <dd>鲜榨苹果汁</dd>
</dl>
```

```js
var menu = document.getElementById('drink-menu');
var drinks = document.getElementsByTagName('dt');
var i, s, menu, drinks;

menu = document.getElementById('drink-menu');
menu.tagName; // 'DL'

drinks = document.getElementsByTagName('dt');
s = '提供的饮料有:';
for (i=0; i<drinks.length; i++) {
    s = s + drinks[i].innerHTML + ',';
}
console.log(s);
//提供的饮料有:摩卡,酸奶,果汁,
```

document对象还有一个cookie属性，可以获取当前页面的Cookie。
> Cookie是由服务器发送的`key-value`标示符。因为`HTTP`协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用`Cookie`来区分。当一个用户成功登录后，服务器发送一个`Cookie`给浏览器，例如`user=ABC123XYZ(加密的字符串)...`，此后，浏览器访问该网站时，会在请求头附上这个`Cookie`，服务器根据`Cookie`即可区分出用户。
>
>`Cookie`还可以存储网站的一些设置，例如，页面显示的语言等等。
>
>`JavaScript`可以通过`document.cookie`读取到当前页面的`Cookie`：
>> `document.cookie; // 'v=123; remember=true; prefer=zh'`
>
>如果引入的第三方的`JavaScript`中存在恶意代码，则www.foo.com网站将直接获取到www.example.com网站的用户登录信息。
>
>为了解决这个问题，服务器在设置`Cookie`时可以使用`httpOnly`，设定了`httpOnly`的`Cookie`将不能被`JavaScript`读取。这个行为由浏览器实现，主流浏览器均支持`httpOnly`选项，`IE`从`IE6 SP1`开始支持。
>
>为了确保安全，服务器端在设置`Cookie`时，应该始终坚持使用`httpOnly`。

#### history

`history`对象保存了浏览器的历史记录，`JavaScript`可以调用`history`对象的`back()`或`forward ()`，相当于用户点击了浏览器的“后退”或“前进”按钮。

这个对象属于历史遗留对象，对于现代`Web`页面来说，由于大量使用`AJAX`和页面交互，简单粗暴地调用`history.back()`可能会让用户感到非常愤怒。

新手开始设计`Web`页面时喜欢在登录页登录成功时调用`history.back()`，试图回到登录前的页面。**这是一种错误的方法。**

- 任何情况，你都不应该使用history这个对象了。

### 操作DOM

由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。

始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：

- 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；
- 遍历：遍历该DOM节点下的子节点，以便进行进一步操作；
- 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；
- 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。

在操作一个`DOM`节点前，我们需要通过各种方式先拿到这个`DOM`节点。最常用的方法是`document.getElementById()`和`document.getElementsByTagName()`，以及`CSS`选择器`document.getElementsByClassName()`。

由于`ID`在`HTML`文档中是唯一的，所以`document.getElementById()`可以直接定位唯一的一个`DOM`节点。`document.getElementsByTagName()`和`document.getElementsByClassName()`总是返回一组`DOM`节点。要精确地选择`DOM`，可以先定位父节点，再从父节点开始选择，以缩小范围。例如：

```js
// 返回ID为'test'的节点：
var test = document.getElementById('test');
// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
var trs = document.getElementById('test-table').getElementsByTagName('tr');
// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
var reds = document.getElementById('test-div').getElementsByClassName('red');
// 获取节点test下的所有直属子节点:
var cs = test.children;
// 获取节点test下第一个、最后一个子节点：
var first = test.firstElementChild;
var last = test.lastElementChild;


```

第二种方法是使用`querySelector()`和`querySelectorAll()`，需要了解`selector`语法，然后使用条件来获取节点，更加方便：

```js
// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector('#q1');

// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll('div.highlighted > p');
```

>注意：低版本的`IE<8`不支持`querySelector`和`querySelectorAll`。`IE8`仅有限支持。

严格地讲，我们这里的`DOM`节点是指`Element`，但是`DOM`节点实际上是`Node`，在`HTML`中，`Node`包括`Element`、`Comment`、`CDATA_SECTION`等很多种，以及根节点`Document`类型，但是，绝大多数时候我们只关心`Element`，也就是实际控制页面结构的`Node`，其他类型的`Node`忽略即可。根节点`Document`已经自动绑定为全局变量`document`。

```html
<!-- HTML结构 -->
<div id="test-div">
<div class="c-red">
    <p id="test-p">JavaScript</p>
    <p>Java</p>
  </div>
  <div class="c-red c-green">
    <p>Python</p>
    <p>Ruby</p>
    <p>Swift</p>
  </div>
  <div class="c-green">
    <p>Scheme</p>
    <p>Haskell</p>
  </div>
</div>
```

```js
'use strict';
// 选择<p>JavaScript</p>:
var js = document.querySelector('#test-p');
// 选择<p>Python</p>,<p>Ruby</p>,<p>Swift</p>:
var arr = document.querySelectorAll('div.c-red.c-green > p');
// 选择<p>Haskell</p>:
var haskell = document.querySelectorAll('div.c-green')[1].lastElementChild;
// 测试:
if (!js || js.innerText !== 'JavaScript') {
    alert('选择JavaScript失败!');
} else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== 'Python' || arr[1].innerText !== 'Ruby' || arr[2].innerText !== 'Swift') {
    console.log('选择Python,Ruby,Swift失败!');
} else if (!haskell || haskell.innerText !== 'Haskell') {
    console.log('选择Haskell失败!');
} else {
    console.log('测试通过!');
}
```

#### 更新DOM

可以直接修改节点的文本，方法有两种：

**一种是修改`innerHTML`属性，这个方式非常强大，不但可以修改一个`DOM`节点的文本内容，还可以直接通过`HTML`片段修改`DOM`节点内部的子树：**

```js
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p>的内部结构已修改
```

用`innerHTML`时要注意，是否需要写入`HTML`。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免`XSS`攻击。

**第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签:**

```js
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本:
p.innerText = '<script>alert("Hi")</script>';
// HTML被自动编码，无法设置一个<script>节点:
// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p>
```

两者的区别在于读取属性时，`innerText`不返回隐藏元素的文本，而`textContent`返回所有文本。另外注意`IE<9`不支持`textContent`。

修改`CSS`也是经常需要的操作。DOM节点的`style`属性对应所有的`CSS`，可以直接获取或设置。因为`CSS`允许`font-size`这样的名称，但它并非`JavaScript`有效的属性名，所以需要在`JavaScript`中改写为驼峰式命名`fontSize`：

```js
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px';
p.style.paddingTop = '2em';
```

#### 插入DOM

如果这个`DOM`节点是空的，例如，`<div></div>`，那么，直接使用`innerHTML = '<span>child</span>'`就可以修改`DOM`节点的内容，相当于“插入”了新的DOM节点。

如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。

有两个办法可以插入新的节点。**一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。** 把`<p id="js">JavaScript</p>`添加到`<div id="list">`的最后一项：例如：

```html
<!--原本-->
<!-- HTML结构 -->
<p id="js">JavaScript</p>
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>

<!--结果-->
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
    <p id="js">JavaScript</p>
</div>
```

```js
var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);
```

因为我们插入的`js`节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。

**更多的时候我们会从零创建一个新的节点，然后插入到指定位置:**

```js
var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);
```

动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个`<style>`节点，然后把它添加到`<head>`节点的末尾，这样就动态地给文档添加了新的CSS定义：

```js
var d = document.createElement('style');
d.setAttribute('type', 'text/css');
d.innerHTML = 'p { color: red }';
document.getElementsByTagName('head')[0].appendChild(d);
```

##### insertBefore

如果我们要把子节点插入到指定的位置怎么办？可以使用`parentElement.insertBefore(newElement, referenceElement);`，子节点会插入到`referenceElement`之前。

```html
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
```

```js
var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
```

可见，使用`insertBefore`重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代`children`属性实现：

```js
var
    i, c,
    list = document.getElementById('list');
for (i = 0; i < list.children.length; i++) {
    c = list.children[i]; // 拿到第i个子节点
}
```

##### 练习

```html
<!-- HTML结构 -->
<ol id="test-list">
    <li class="lang">Scheme</li>
    <li class="lang">JavaScript</li>
    <li class="lang">Python</li>
    <li class="lang">Ruby</li>
    <li class="lang">Haskell</li>
</ol>
```

按字符串顺序重新排序DOM节点：

```js
'use strict';
// sort list:
var arr = [],
    list = document.querySelectorAll('li.lang'),
div_list = document.querySelector('#test-list');
list.forEach(e =>{
    arr.push(e.innerHTML);
});
arr.sort();
console.log(arr);
arr.forEach(e =>{
console.log(e);
let i,c;
    for(i= 0; i< list.length;i++){
        c=list[i];
        if(c.innerHTML === e){
            div_list .appendChild(c);
        }

    }
});
// 测试:
;(function () {
    var
        arr, i,
        t = document.getElementById('test-list');
    if (t && t.children && t.children.length === 5) {
        arr = [];
        for (i=0; i<t.children.length; i++) {
            arr.push(t.children[i].innerText);
        }
        if (arr.toString() === ['Haskell', 'JavaScript', 'Python', 'Ruby', 'Scheme'].toString()) {
            console.log('测试通过!');
        }
        else {
            console.log('测试失败: ' + arr.toString());
        }
    }
    else {
        console.log('测试失败!');
    }
})();
```

#### 删除DOM

要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉：

```js
// 拿到待删除节点:
var self = document.getElementById('to-be-removed');
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
```

## md的使用

空格的使用：&nbsp; &nbsp;

内部链接:[内部链接]

外部链接:[外部链接]

---
[`Babel`]:https://babeljs.io/
[浏览器]:https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997647015f03abc1bb5f46129a7526292a12ab26000
[内部链接]:##md的使用
[外部链接]:./2018·8·2.md/###Date