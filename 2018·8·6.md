# js note

## 创建对象

![创建对象_1](./pic/对象创建_1.png)

红色箭头是原型链。注意，`Student.prototype`指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性`constructor`，指向Student函数本身。\
另外，函数Student恰好有个属性`prototype`指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。\
现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。

>要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype：

![创建对象_2]

```js
Cat.prototype.say = function () {
  return 'Hello, '+ this.name+'!';
};
```

## 原型继承

在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。/
由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。/
我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：
![原型继承](./pic/原型继承_1.png)

```js
// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}
// 空函数F:
function F() {
}
// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;
// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();
// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;
// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2
// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true
// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
```

- *如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：*

```js
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
```

- **这个inherits()函数可以复用：**

```js
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
```

> JavaScript的原型继承实现方式就是：
- >定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；
- >借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；
- >继续在新的构造函数的原型上定义新方法。

---
[创建对象_2]:./pic/对象创建_2.png